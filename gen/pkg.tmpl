package {{ .Name }}

import (
    "github.com/bobappleyard/er"
    "github.com/bobappleyard/er/rtl"
)

type Model struct {
    {{range .Types}}
    {{goName .Name}} tableOf{{goName .Name}}
    {{end}}
}

func New() *Model {
    m := new(Model)
    {{range .Types}}m.{{goName .Name}}.init(m)
    {{end -}}
    return m
}

func (m *Model) Validate() error {
    {{range .Types}}if err := m.{{goName .Name}}.validate(); err != nil { return err}
    {{end -}}
    return nil
}

func (m *Model) Unmarshal(bs []byte) error {
    p := rtl.NewReader(bs)
    for p.Next() {
        switch p.Name() {
        {{range dependants nil}}
        case {{printf "%q" .Name}}:
            m.{{goName .Name}}.parse(p.Record())
        {{end}}
        default:
            p.SetErr(er.ErrInvalidRecord)
        }
    }
    return p.Err()
}

{{range .Types}}

type {{goName .Name}} struct {
    {{range .Attributes}}{{goName .Name}} {{attrType .}}
    {{end -}}
    model *Model
}

type attrsOf{{goName .Name}} struct {
    {{range .Attributes}}{{goName .Name}} {{attrType .}}
    {{end -}}
}

type setOf{{goName .Name}} struct {
    {{range .Attributes}}{{goName .Name}} {{columnType .}}
    {{end -}}

    model *Model
    query rtl.Query
    rows []attrsOf{{goName .Name}}
}

type tableOf{{goName .Name}} struct {
    setOf{{goName .Name}}
}

func (s *tableOf{{goName .Name}}) init(m *Model) {
    s.model = m
    s.query = rtl.All()
    {{range $i, $e := .Attributes}}
    s.{{goName .Name}} = {{columnInit .}}({{$i}}, func(idx int) {{attrType .}} {
        return s.rows[idx].{{goName .Name}}
    })
    {{end}}
}

func (s *tableOf{{goName .Name}}) validate() error {
    {{if ne (len .Relationships) 0}}
    return s.ForEach(func(e {{goName .Name}}) error {
        {{- range .Relationships}}
        {
            q := e.queryFor{{goName .Name}}()
            if q.Count() != 1 {
                return er.ErrMissingEntity
            }{{if ne (len .Constraints) 0}}
            t := q.One()
            {{- range .Constraints}}
            if e{{range .Diagonal.Components}}.{{goName .Rel.Name}}(){{end}} != t{{range .Riser.Components}}.{{goName .Rel.Name}}(){{end}} {
                return er.ErrMissingEntity
            }{{end}}{{end}}
        }{{end}}
        return nil
    })
    {{else}}
    return nil
    {{end}}
}

{{if .Dependency.Rel}}
{{- if .Dependency.Sequence}}
func (s *tableOf{{goName .Name}}) parse(p *rtl.Reader, parent {{goName .Dependency.Rel.Target.Name}}, seq int) {
{{else}}
func (s *tableOf{{goName .Name}}) parse(p *rtl.Reader, parent {{goName .Dependency.Rel.Target.Name}}) {
{{end -}}
    var e {{goName .Name}}
    {{range .Dependency.Rel.Implementation}}e.{{goName .Source.Name}} = parent.{{goName .Target.Name}}
    {{end -}}
    {{if .Dependency.Sequence}}e.Seq = seq
    {{end -}}
{{else}}
func (s *tableOf{{goName .Name}}) parse(p *rtl.Reader) {
    var e {{goName .Name}}
{{end}}
    {{range dependants .}}
    {{if .Dependency.Sequence}}var seqOf{{goName .Name}} int{{end}}
    {{end}}
    for p.Next() {
        switch p.Name() {
        {{range newAttrs .}}case {{printf "%q" .Name}}:
            e.{{goName .Name}} = p.{{attrParse .}}()
        {{end -}}
        {{range dependants .}}case {{printf "%q" .Name}}:
            {{if .Dependency.Sequence}}s.model.{{goName .Name}}.parse(p.Record(), e, seqOf{{goName .Name}})
            seqOf{{goName .Name}}++
            {{else}}s.model.{{goName .Name}}.parse(p.Record(), e)
            {{end -}}
        {{end -}}
        default:
            p.SetErr(er.ErrInvalidRecord)
        }
    }
    if p.Err() == nil {
        p.SetErr(s.Insert(e))
    }
}

{{range .Relationships}}

func (e {{goName .Source.Name}}) {{goName .Name}}() {{goName .Target.Name}} {
    q := e.queryFor{{goName .Name}}()
    return q.One()
}

func (s setOf{{goName .Source.Name}}) {{goName .Name}}() setOf{{goName .Target.Name}} {
    var res setOf{{goName .Target.Name}}
    s.ForEach(func(e {{goName .Source.Name}}) error {
        res = res.Union(e.queryFor{{goName .Name}}())
        return nil
    })
    return res
}

func (e {{goName .Source.Name}}) queryFor{{goName .Name}}() setOf{{goName .Target.Name}} {
    var q rtl.Query
    t := e.model.{{goName .Target.Name}}
    {{range .Implementation}}q = q.And(t.{{goName .Target.Name}}.Eq(e.
        {{- range .BasePath}}{{goName .Rel.Name}}().{{end -}}{{goName .Source.Name -}}
    ))
    {{end -}}
    return e.model.{{goName .Target.Name}}.Where(q)
}

{{end}}

func (s setOf{{goName .Name}}) ForEach(f func({{goName .Name}}) error) error {
    q := rtl.EvalQuery(s.query, len(s.rows))
    for q.Next() {
        d := s.rows[q.This()]
        if err := f({{goName .Name}}{
            model: s.model,
            {{range .Attributes}}{{goName .Name}}: d.{{goName .Name}},
            {{end -}}
        }); err != nil { return err }
    }
    return nil
}

func (s setOf{{goName .Name}}) Count() int {
    c := 0
    s.ForEach(func({{goName .Name}}) error {
        c++
        return nil
    })
    return c
}

func (s setOf{{goName .Name}}) One() {{goName .Name}} {
    var res {{goName .Name}}
    s.ForEach(func(t {{goName .Name}}) error {
        res = t
        return nil
    })
    return res
}

func (s setOf{{goName .Name}}) Many() []{{goName .Name}} {
    var res []{{goName .Name}}
    s.ForEach(func(t {{goName .Name}}) error {
        res = append(res, t)
        return nil
    })
    return res
}

func (s setOf{{goName .Name}}) Where(q rtl.Query) setOf{{goName .Name}} {
    res := s
    res.query = q.And(res.query)
    return res
}

func (s setOf{{goName .Name}}) Union(t setOf{{goName .Name}}) setOf{{goName .Name}} {
    if s.model == nil {
        return t
    }
    if t.model == nil {
        return s
    }
    res := s
    res.query = s.query.Or(t.query)
    return res
}

func (s setOf{{goName .Name}}) Intersection(t setOf{{goName .Name}}) setOf{{goName .Name}} {
    if s.model == nil {
        return t
    }
    if t.model == nil {
        return s
    }
    res := s
    res.query = s.query.And(t.query)
    return res
}

func (s *tableOf{{goName .Name}}) Insert(e {{goName .Name}}) error {
    e.model = s.model
    r := rtl.EvalQuery(e.identity(), len(s.rows))
    if r.Next() { return er.ErrDuplicateKey }
    s.clearSpace(r)
    s.writeRow(r, e)
    return nil
}

func (s *tableOf{{goName .Name}}) Update(e {{goName .Name}}) error {
    e.model = s.model
    r := rtl.EvalQuery(e.identity(), len(s.rows))
    if !r.Next() { return er.ErrMissingEntity }
    s.writeRow(r, e)
    return nil
}

func (s *tableOf{{goName .Name}}) Delete(e {{goName .Name}}) error {
    e.model = s.model
    r := rtl.EvalQuery(e.identity(), len(s.rows))
    if !r.Next() { return er.ErrMissingEntity }
    copy(s.rows[r.This():], s.rows[r.This():+1])
    s.rows = s.rows[:len(s.rows)-1]
    return nil
}

func (e {{goName .Name}}) identity() rtl.Query {
    var query rtl.Query
    s := e.model.{{goName .Name}}
    {{range .Attributes}}{{if .Identifying}}query = query.And(s.{{goName .Name}}.Eq(e.{{goName .Name}}))
    {{end}}{{end -}}
    return query
}

func (s *tableOf{{goName .Name}}) clearSpace(r *rtl.QueryResult) {
    s.rows = append(s.rows, attrsOf{{goName .Name}}{})
    copy(s.rows[r.This()+1:], s.rows[r.This():])
}

func (s *tableOf{{goName .Name}}) writeRow(r *rtl.QueryResult, e {{goName .Name}}) {
    s.rows[r.This()] = attrsOf{{goName .Name}} {
    {{range .Attributes}}{{goName .Name}}: e.{{goName .Name}},
    {{end -}}
    }
}

{{end}}